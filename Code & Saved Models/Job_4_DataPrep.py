import pandas as pd
import numpy as np
from sklearn.preprocessing import OneHotEncoder
import numpy as np
from sklearn.preprocessing import Normalizer
from scipy.sparse import vstack, csr_matrix, save_npz, load_npz


import numpy as np
import matplotlib.pyplot as plt
from matplotlib.colors import ListedColormap
from sklearn.model_selection import train_test_split



dtypes = {
        'ProductName':                                          'category',
        'EngineVersion':                                        'category',
        'AppVersion':                                           'category',
        'AvSigVersion':                                         'category',
        'AVProductStatesIdentifier':                            'float32',
        'AVProductsEnabled':                                    'float16',
        'CountryIdentifier':                                    'float64',
        'CityIdentifier':                                       'float64',
        'OrganizationIdentifier':                               'float16',
        'GeoNameIdentifier':                                    'float16',
        'Platform':                                             'category',
        'Processor':                                            'category',
        'OsVer':                                                'category',
        'OsBuild':                                              'int16',
        'OsSuite':                                              'int16',
        'SkuEdition':                                           'category',
        'IsProtected':                                          'float16',
        'SmartScreen':                                          'category',
        'Firewall':                                             'float16',
        'Census_ProcessorCoreCount':                            'float16',
        'Census_ProcessorManufacturerIdentifier':               'float16',
        'Census_ProcessorModelIdentifier':                      'float16',
        'Census_OSVersion':                                     'category',
        'Census_OSArchitecture':                                'category',
        'Census_OSBranch':                                      'category',
        'Census_OSBuildNumber':                                 'int16',
        'Census_OSBuildRevision':                               'int32',
        'Census_OSEdition':                                     'category',
        'Census_OSSkuName':                                     'category',
        'Census_OSInstallTypeName':                             'category',
        'Census_OSWUAutoUpdateOptionsName':                     'category',
        'Census_GenuineStateName':                              'category',
        'Census_ActivationChannel':                             'category',
        'Census_FlightRing':                                    'category',
        'Wdft_IsGamer':                                         'float16',
        'HasDetections':                                        'int8'
        }
    
train_df = pd.read_csv('D:/UNT/Sem 5/data/train.csv/train_interm_s3.csv',dtype= dtypes,low_memory=False)
train_df.isna().any()
train_df['AVProductStatesIdentifier'].fillna( method ='ffill', inplace = True) 
train_df['OrganizationIdentifier'].interpolate( inplace = True) 
train_df['GeoNameIdentifier'].interpolate( inplace = True) 
train_df['IsProtected'].interpolate(inplace = True) 
train_df['SmartScreen'].interpolate(method ='bfill', inplace = True) 
train_df['Firewall'].interpolate(method ='linear', inplace = True) 
train_df['Census_ProcessorCoreCount'].fillna(train_df['Census_ProcessorCoreCount'].mode()[0], inplace=True)
train_df['Census_ProcessorManufacturerIdentifier'].fillna(train_df['Census_ProcessorManufacturerIdentifier'].mode()[0], inplace=True)
train_df['Census_ProcessorModelIdentifier'].fillna(train_df['Census_ProcessorModelIdentifier'].mode()[0], inplace=True)
train_df['Wdft_IsGamer'].fillna(train_df['Wdft_IsGamer'].mode()[0], inplace=True)
train_df['CityIdentifier'].fillna(train_df['CityIdentifier'].mode()[0], inplace=True)
train_df['AVProductsEnabled'].fillna(train_df['AVProductsEnabled'].mode()[0], inplace=True)
train_df['AVProductsInstalled'].fillna(train_df['AVProductsInstalled'].mode()[0], inplace=True)
train_df['CityIdentifier'][train_df['CityIdentifier'] > 65500] = train_df.loc[train_df['CityIdentifier'] != np.inf, 'CityIdentifier'].mode()
train_df['CityIdentifier'].fillna(train_df.loc[train_df['CityIdentifier'] != np.inf, 'CityIdentifier'].mode(),inplace=True)
train_df.isna().any()
train_df['CityIdentifier'].fillna(train_df['CityIdentifier'].mode()[0], inplace=True)

train_df.to_csv('D:/UNT/Sem 5/data/train.csv/train_interm_s4.csv',index=False)

Y_Train = np.array(train_df.HasDetections)
np.save('Train_array_Y',Y_Train)

train_df.drop(['HasDetections'],inplace=True,axis=1 )


train_df_cont =  train_df[['AVProductStatesIdentifier','AVProductsEnabled','CountryIdentifier','CityIdentifier','OrganizationIdentifier','GeoNameIdentifier','OsBuild','OsSuite','IsProtected','Firewall','Census_ProcessorCoreCount','Census_ProcessorManufacturerIdentifier','Census_ProcessorModelIdentifier','Census_OSBuildNumber','Census_OSBuildRevision','Wdft_IsGamer']]

train_df.drop(['AVProductStatesIdentifier','AVProductsEnabled','CountryIdentifier','CityIdentifier','OrganizationIdentifier','GeoNameIdentifier','OsBuild','OsSuite','IsProtected','Firewall','Census_ProcessorCoreCount','Census_ProcessorManufacturerIdentifier','Census_ProcessorModelIdentifier','Census_OSBuildNumber','Census_OSBuildRevision','Wdft_IsGamer'],inplace=True,axis=1)

from sklearn.preprocessing import StandardScaler
scaler = StandardScaler()
train_df_cont = scaler.fit_transform(train_df_cont)


train_df_final = np.hstack((train_df.values,train_df_cont))
del train_df_cont

enc = OneHotEncoder(categories='auto',handle_unknown='ignore', sparse=True,dtype='uint8')    
train_df_final = enc.fit_transform(train_df_final)

save_npz('train_final.npz', train_df_final, compressed=True)

np.save('Train_array_Y',Y_Train)
train_df_final = load_npz('train_final.npz')
Y_Train        = np.load('Train_array_Y.npy')
from sklearn.ensemble import GradientBoostingClassifier
from sklearn.metrics import accuracy_score
import pickle
clf = GradientBoostingClassifier(random_state=0)
clf.fit(train_df_final[:100000,:], Y_Train[:100000])
Y_Predict = clf.predict(train_df_final[8100000:8200000,:])
print(accuracy_score(Y_Train[8100000:8200000], Y_Predict))
#0.62023
# save
#with open('model1.pkl','wb') as f:
#    pickle.dump(clf,f)

clf.fit(train_df_final[100000:1500000,:], Y_Train[1000000:1500000])
Y_Predict = clf.predict(train_df_final[8100000:8200000,:])
print(accuracy_score(Y_Train[8100000:8200000], Y_Predict))
#0.62023
# save
#with open('model2.pkl','wb') as f:
#    pickle.dump(clf,f)

clf_model_2 = pickle.load(open('model2.pkl', 'rb'))
Y_Predict = clf_model_2.predict(train_df_final[8100000:8200000,:])
print(accuracy_score(Y_Train[8100000:8200000], Y_Predict))

 from sklearn.ensemble import AdaBoostClassifier
 from sklearn.ensemble import RandomForestClassifier
 from sklearn.ensemble import GradientBoostingClassifier
 
classifiers = [
    RandomForestClassifier(max_depth=5, n_estimators=50,random_state=0),
    AdaBoostClassifier(random_state=0),
    GradientBoostingClassifier(random_state=0)
    ]
    
names = [ "RandomForest",  "AdaBoost", "GBC"]

X_train = train_df_final[:1000000,:].astype('float32')
y_train =  Y_Train[:1000000].astype('float32')

X_test = train_df_final[800000:830000,:].astype('float32')
y_test = Y_Train[800000:830000].astype('float32')


for name, clf in zip(names, classifiers):
    print('_______________________',name,'________________________')
    clf.fit(X_train, y_train)
    with open('model'+name+'.pkl','wb') as f:
        pickle.dump(clf,f)
    Y_Predict = clf.predict(train_df_final[800000:830000,:])
    print(accuracy_score(Y_Train[800000:830000], Y_Predict))

###############################################################################
from xgboost import XGBClassifier
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score

# fit model no training data
model = XGBClassifier()


model.fit(X_train, y_train)

# make predictions for test data
y_pred = model.predict(X_test)
predictions = [round(value) for value in y_pred]
accuracy = accuracy_score(y_test, predictions)
print("Accuracy: %.2f%%" % (accuracy * 100.0))

with open('model_XBG.pkl','wb') as f:
    pickle.dump(model,f)

###############################################################################

from numpy import mean
from numpy import std
from sklearn.datasets import make_classification
from sklearn.model_selection import cross_val_score
from sklearn.model_selection import RepeatedStratifiedKFold
from lightgbm import LGBMClassifier
# define the model
lgb_model  = LGBMClassifier(max_depth=10,
                                   n_estimators=150,
                                   learning_rate=0.1,
                                   num_leaves=24,
                                   objective='binary', 
                                   n_jobs=-1)

X_train_lgb = train_df_final[:2000000,:].astype('float32')
y_train_lgb =  Y_Train[:2000000].astype('float32')

X_test_lgb = train_df_final[800000:850000,:].astype('float32')
y_test_lgb = Y_Train[800000:850000].astype('float32')


lgb_model.fit(X_train_lgb, y_train_lgb, eval_metric='auc',eval_set=[(X_test_lgb, y_test_lgb)])
lgb_model.fit(X_train, y_train, eval_metric='auc',eval_set=[(X_test, y_test)])


with open('model_LBG.pkl','wb') as f:
    pickle.dump(lgb_model,f)

# evaluate the model
cv = RepeatedStratifiedKFold(n_splits=10, n_repeats=3, random_state=1)
n_scores = cross_val_score(lgb_model, X_train_lgb, y_train_lgb, scoring='accuracy', cv=cv, n_jobs=-1)
print('Accuracy: %.3f (%.3f)' % (mean(n_scores), std(n_scores)))

###############################################################################